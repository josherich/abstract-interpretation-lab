// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Lexing = require("bs-platform/lib/js/lexing.js");
var Lexer$AiProject = require("./lexer.bs.js");
var Parser$AiProject = require("./parser.bs.js");
var Printer$AiProject = require("./printer.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var AbstractTree$AiProject = require("./abstractTree.bs.js");
var AbstractDomain$AiProject = require("./abstractDomain.bs.js");
var AbstractSyntax$AiProject = require("./abstractSyntax.bs.js");
var AbstractInterpreter$AiProject = require("./abstractInterpreter.bs.js");

function run(input) {
  var lexbuf = Lexing.from_string(input);
  try {
    var p$prime = Parser$AiProject.prog(Lexer$AiProject.token, lexbuf);
    var p$prime$prime = AbstractSyntax$AiProject.built_abstract_syntax(p$prime);
    var vl = AbstractTree$AiProject.vars(p$prime);
    var p$prime$prime$prime = AbstractInterpreter$AiProject.abstractInterpreter(p$prime$prime, (function (param) {
            return AbstractDomain$AiProject.initialP(/* () */0, param);
          }), vl);
    return Printer$AiProject.print_labelled_node(p$prime$prime$prime, 0, vl);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn[0] === Lexer$AiProject.$$Error) {
      return "error: " + exn[1];
    } else if (exn === Parser$AiProject.$$Error) {
      return "error: At offset " + (String(Lexing.lexeme_start(lexbuf)) + ": syntax error.\n%!");
    } else {
      throw exn;
    }
  }
}

run("while (0<1){ break; x=1; }");

exports.run = run;
/*  Not a pure module */
