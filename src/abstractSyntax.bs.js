// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var AbstractTree$AiProject = require("./abstractTree.bs.js");
var AbstractDomain$AiProject = require("./abstractDomain.bs.js");

function at_stmt(s) {
  switch (s.tag | 0) {
    case 4 : 
        return s[3][0];
    case 2 : 
    case 6 : 
        return s[0][0];
    case 0 : 
    case 7 : 
        return s[1][0];
    default:
      return s[2][0];
  }
}

function select_at(param) {
  return param[1];
}

function property_at(s) {
  switch (s.tag | 0) {
    case 4 : 
        return select_at(s[3]);
    case 2 : 
    case 6 : 
        return select_at(s[0]);
    case 0 : 
    case 7 : 
        return select_at(s[1]);
    default:
      return select_at(s[2]);
  }
}

function after_stmt(s) {
  switch (s.tag | 0) {
    case 4 : 
        return s[3][2];
    case 2 : 
    case 6 : 
        return s[0][2];
    case 0 : 
    case 7 : 
        return s[1][2];
    default:
      return s[2][2];
  }
}

function select_after(param) {
  return param[3];
}

function property_after(s) {
  switch (s.tag | 0) {
    case 4 : 
        return select_after(s[3]);
    case 2 : 
    case 6 : 
        return select_after(s[0]);
    case 0 : 
    case 7 : 
        return select_after(s[1]);
    default:
      return select_after(s[2]);
  }
}

function escape_stmt(s) {
  switch (s.tag | 0) {
    case 4 : 
        return s[3][4];
    case 2 : 
    case 6 : 
        return s[0][4];
    case 0 : 
    case 7 : 
        return s[1][4];
    default:
      return s[2][4];
  }
}

function break_stmt(s) {
  switch (s.tag | 0) {
    case 4 : 
        return s[3][5];
    case 2 : 
    case 6 : 
        return s[0][5];
    case 0 : 
    case 7 : 
        return s[1][5];
    default:
      return s[2][5];
  }
}

function select_break(param) {
  return param[6];
}

function property_break(s) {
  switch (s.tag | 0) {
    case 4 : 
        return select_break(s[3]);
    case 2 : 
    case 6 : 
        return select_break(s[0]);
    case 0 : 
    case 7 : 
        return select_break(s[1]);
    default:
      return select_break(s[2]);
  }
}

function is_in_stmt(l, _s) {
  while(true) {
    var s = _s;
    switch (s.tag | 0) {
      case 0 : 
          var match = s[1];
          if (Caml_obj.caml_equal(l, match[0]) || Caml_obj.caml_equal(l, match[2])) {
            return true;
          } else {
            return is_in_stmt_list(l, s[0]);
          }
      case 1 : 
          return Caml_obj.caml_equal(l, s[2][0]);
      case 4 : 
          if (Caml_obj.caml_equal(l, s[3][0]) || is_in_stmt(l, s[1])) {
            return true;
          } else {
            _s = s[2];
            continue ;
          }
      case 3 : 
      case 5 : 
          if (Caml_obj.caml_equal(l, s[2][0])) {
            return true;
          } else {
            _s = s[1];
            continue ;
          }
      case 2 : 
      case 6 : 
          return Caml_obj.caml_equal(l, s[0][0]);
      case 7 : 
          if (Caml_obj.caml_equal(l, s[1][0])) {
            return true;
          } else {
            return is_in_stmt_list(l, s[0]);
          }
      
    }
  };
}

function is_in_stmt_list(l, _sl) {
  while(true) {
    var sl = _sl;
    if (sl) {
      if (is_in_stmt(l, sl[0])) {
        return true;
      } else {
        _sl = sl[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function void_label_tree(s) {
  var bot = function (param) {
    return AbstractDomain$AiProject.bot(/* () */0, param);
  };
  var void_labelling = /* tuple */[
    0,
    bot,
    0,
    bot,
    false,
    0,
    bot
  ];
  switch (s.tag | 0) {
    case 0 : 
        return /* Prog */Block.__(0, [
                  void_label_tree_list(s[0]),
                  void_labelling
                ]);
    case 1 : 
        return /* Assign */Block.__(1, [
                  s[0],
                  s[1],
                  void_labelling
                ]);
    case 2 : 
        return /* Emptystmt */Block.__(2, [void_labelling]);
    case 3 : 
        return /* If */Block.__(3, [
                  s[0],
                  void_label_tree(s[1]),
                  void_labelling
                ]);
    case 4 : 
        return /* Ifelse */Block.__(4, [
                  s[0],
                  void_label_tree(s[1]),
                  void_label_tree(s[2]),
                  void_labelling
                ]);
    case 5 : 
        return /* While */Block.__(5, [
                  s[0],
                  void_label_tree(s[1]),
                  void_labelling
                ]);
    case 6 : 
        return /* Break */Block.__(6, [void_labelling]);
    case 7 : 
        return /* Stmtlist */Block.__(7, [
                  void_label_tree_list(s[0]),
                  void_labelling
                ]);
    
  }
}

function void_label_tree_list(sl) {
  if (sl) {
    var sl$prime = sl[1];
    var s$prime = sl[0];
    if (sl$prime) {
      return /* :: */[
              void_label_tree(s$prime),
              void_label_tree_list(sl$prime)
            ];
    } else {
      return /* :: */[
              void_label_tree(s$prime),
              /* [] */0
            ];
    }
  } else {
    return /* [] */0;
  }
}

function set_at_tree(s, l) {
  switch (s.tag | 0) {
    case 0 : 
        var match = s[1];
        var match$1 = set_at_tree_list(s[0], l);
        return /* tuple */[
                /* Prog */Block.__(0, [
                    match$1[0],
                    /* tuple */[
                      l,
                      match[1],
                      match[2],
                      match[3],
                      match[4],
                      match[5],
                      match[6]
                    ]
                  ]),
                match$1[1]
              ];
    case 1 : 
        var match$2 = s[2];
        return /* tuple */[
                /* Assign */Block.__(1, [
                    s[0],
                    s[1],
                    /* tuple */[
                      l,
                      match$2[1],
                      match$2[2],
                      match$2[3],
                      match$2[4],
                      match$2[5],
                      match$2[6]
                    ]
                  ]),
                l + 1 | 0
              ];
    case 2 : 
        var match$3 = s[0];
        return /* tuple */[
                /* Emptystmt */Block.__(2, [/* tuple */[
                      l,
                      match$3[1],
                      match$3[2],
                      match$3[3],
                      match$3[4],
                      match$3[5],
                      match$3[6]
                    ]]),
                l + 1 | 0
              ];
    case 3 : 
        var match$4 = s[2];
        var match$5 = set_at_tree(s[1], l + 1 | 0);
        return /* tuple */[
                /* If */Block.__(3, [
                    s[0],
                    match$5[0],
                    /* tuple */[
                      l,
                      match$4[1],
                      match$4[2],
                      match$4[3],
                      match$4[4],
                      match$4[5],
                      match$4[6]
                    ]
                  ]),
                match$5[1]
              ];
    case 4 : 
        var match$6 = s[3];
        var match$7 = set_at_tree(s[1], l + 1 | 0);
        var match$8 = set_at_tree(s[2], match$7[1]);
        return /* tuple */[
                /* Ifelse */Block.__(4, [
                    s[0],
                    match$7[0],
                    match$8[0],
                    /* tuple */[
                      l,
                      match$6[1],
                      match$6[2],
                      match$6[3],
                      match$6[4],
                      match$6[5],
                      match$6[6]
                    ]
                  ]),
                match$8[1]
              ];
    case 5 : 
        var match$9 = s[2];
        var match$10 = set_at_tree(s[1], l + 1 | 0);
        return /* tuple */[
                /* While */Block.__(5, [
                    s[0],
                    match$10[0],
                    /* tuple */[
                      l,
                      match$9[1],
                      match$9[2],
                      match$9[3],
                      match$9[4],
                      match$9[5],
                      match$9[6]
                    ]
                  ]),
                match$10[1]
              ];
    case 6 : 
        var match$11 = s[0];
        return /* tuple */[
                /* Break */Block.__(6, [/* tuple */[
                      l,
                      match$11[1],
                      match$11[2],
                      match$11[3],
                      match$11[4],
                      match$11[5],
                      match$11[6]
                    ]]),
                l + 1 | 0
              ];
    case 7 : 
        var match$12 = s[1];
        var match$13 = set_at_tree_list(s[0], l);
        return /* tuple */[
                /* Stmtlist */Block.__(7, [
                    match$13[0],
                    /* tuple */[
                      l,
                      match$12[1],
                      match$12[2],
                      match$12[3],
                      match$12[4],
                      match$12[5],
                      match$12[6]
                    ]
                  ]),
                match$13[1]
              ];
    
  }
}

function set_at_tree_list(sl, l) {
  if (sl) {
    var sl$prime = sl[1];
    var s$prime = sl[0];
    if (sl$prime) {
      var match = set_at_tree_list(sl$prime, l);
      var match$1 = set_at_tree(s$prime, match[1]);
      return /* tuple */[
              /* :: */[
                match$1[0],
                match[0]
              ],
              match$1[1]
            ];
    } else {
      var match$2 = set_at_tree(s$prime, l);
      return /* tuple */[
              /* :: */[
                match$2[0],
                /* [] */0
              ],
              match$2[1]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            l
          ];
  }
}

function set_labelling_tree(s, after, $$break) {
  switch (s.tag | 0) {
    case 0 : 
        var match = s[1];
        var match$1 = set_labelling_tree_list(s[0], after, $$break);
        if (match$1[1]) {
          Pervasives.print_string("Error: no break allowed out of a program\n");
        }
        return /* tuple */[
                /* Prog */Block.__(0, [
                    match$1[0],
                    /* tuple */[
                      match[0],
                      match[1],
                      after,
                      match[3],
                      false,
                      0,
                      match[6]
                    ]
                  ]),
                false
              ];
    case 1 : 
        var match$2 = s[2];
        return /* tuple */[
                /* Assign */Block.__(1, [
                    s[0],
                    s[1],
                    /* tuple */[
                      match$2[0],
                      match$2[1],
                      after,
                      match$2[3],
                      false,
                      0,
                      match$2[6]
                    ]
                  ]),
                false
              ];
    case 2 : 
        var match$3 = s[0];
        return /* tuple */[
                /* Emptystmt */Block.__(2, [/* tuple */[
                      match$3[0],
                      match$3[1],
                      after,
                      match$3[3],
                      false,
                      0,
                      match$3[6]
                    ]]),
                false
              ];
    case 3 : 
        var match$4 = s[2];
        var brP = match$4[6];
        var afP = match$4[3];
        var atP = match$4[1];
        var at = match$4[0];
        var b = s[0];
        var match$5 = set_labelling_tree(s[1], after, $$break);
        var es$prime = match$5[1];
        var st$prime = match$5[0];
        if (es$prime) {
          return /* tuple */[
                  /* If */Block.__(3, [
                      b,
                      st$prime,
                      /* tuple */[
                        at,
                        atP,
                        after,
                        afP,
                        es$prime,
                        $$break,
                        brP
                      ]
                    ]),
                  es$prime
                ];
        } else {
          return /* tuple */[
                  /* If */Block.__(3, [
                      b,
                      st$prime,
                      /* tuple */[
                        at,
                        atP,
                        after,
                        afP,
                        es$prime,
                        0,
                        brP
                      ]
                    ]),
                  es$prime
                ];
        }
    case 4 : 
        var match$6 = s[3];
        var brP$1 = match$6[6];
        var afP$1 = match$6[3];
        var atP$1 = match$6[1];
        var at$1 = match$6[0];
        var b$1 = s[0];
        var match$7 = set_labelling_tree(s[1], after, $$break);
        var st$prime$1 = match$7[0];
        var match$8 = set_labelling_tree(s[2], after, $$break);
        var se$prime = match$8[0];
        var es$prime$prime$prime = match$7[1] || match$8[1];
        if (es$prime$prime$prime) {
          return /* tuple */[
                  /* Ifelse */Block.__(4, [
                      b$1,
                      st$prime$1,
                      se$prime,
                      /* tuple */[
                        at$1,
                        atP$1,
                        after,
                        afP$1,
                        es$prime$prime$prime,
                        $$break,
                        brP$1
                      ]
                    ]),
                  es$prime$prime$prime
                ];
        } else {
          return /* tuple */[
                  /* Ifelse */Block.__(4, [
                      b$1,
                      st$prime$1,
                      se$prime,
                      /* tuple */[
                        at$1,
                        atP$1,
                        after,
                        afP$1,
                        es$prime$prime$prime,
                        0,
                        brP$1
                      ]
                    ]),
                  es$prime$prime$prime
                ];
        }
    case 5 : 
        var match$9 = s[2];
        var at$2 = match$9[0];
        var match$10 = set_labelling_tree(s[1], at$2, after);
        return /* tuple */[
                /* While */Block.__(5, [
                    s[0],
                    match$10[0],
                    /* tuple */[
                      at$2,
                      match$9[1],
                      after,
                      match$9[3],
                      false,
                      0,
                      match$9[6]
                    ]
                  ]),
                false
              ];
    case 6 : 
        var match$11 = s[0];
        return /* tuple */[
                /* Break */Block.__(6, [/* tuple */[
                      match$11[0],
                      match$11[1],
                      after,
                      match$11[3],
                      true,
                      $$break,
                      match$11[6]
                    ]]),
                true
              ];
    case 7 : 
        var match$12 = s[1];
        var brP$2 = match$12[6];
        var afP$2 = match$12[3];
        var atP$2 = match$12[1];
        var at$3 = match$12[0];
        var match$13 = set_labelling_tree_list(s[0], after, $$break);
        var es$prime$1 = match$13[1];
        var sl$prime = match$13[0];
        if (es$prime$1) {
          return /* tuple */[
                  /* Stmtlist */Block.__(7, [
                      sl$prime,
                      /* tuple */[
                        at$3,
                        atP$2,
                        after,
                        afP$2,
                        es$prime$1,
                        $$break,
                        brP$2
                      ]
                    ]),
                  es$prime$1
                ];
        } else {
          return /* tuple */[
                  /* Stmtlist */Block.__(7, [
                      sl$prime,
                      /* tuple */[
                        at$3,
                        atP$2,
                        after,
                        afP$2,
                        es$prime$1,
                        0,
                        brP$2
                      ]
                    ]),
                  es$prime$1
                ];
        }
    
  }
}

function set_labelling_tree_list(sl, after, $$break) {
  if (sl) {
    var sl$prime = sl[1];
    var s$prime = sl[0];
    if (sl$prime) {
      var match = set_labelling_tree_list(sl$prime, at_stmt(s$prime), $$break);
      var match$1 = set_labelling_tree(s$prime, after, $$break);
      var es$prime$prime$prime = match[1] || match$1[1];
      return /* tuple */[
              /* :: */[
                match$1[0],
                match[0]
              ],
              es$prime$prime$prime
            ];
    } else {
      var match$2 = set_labelling_tree(s$prime, after, $$break);
      return /* tuple */[
              /* :: */[
                match$2[0],
                /* [] */0
              ],
              match$2[1]
            ];
    }
  } else {
    return /* tuple */[
            /* [] */0,
            false
          ];
  }
}

function built_abstract_syntax(p) {
  AbstractDomain$AiProject.initialize(AbstractTree$AiProject.vars(p));
  var p$prime = void_label_tree(p);
  var match = set_at_tree(p$prime, 1);
  var next = match[1];
  return set_labelling_tree(match[0], next, next)[0];
}

var void_label = 0;

exports.at_stmt = at_stmt;
exports.select_at = select_at;
exports.property_at = property_at;
exports.after_stmt = after_stmt;
exports.select_after = select_after;
exports.property_after = property_after;
exports.escape_stmt = escape_stmt;
exports.break_stmt = break_stmt;
exports.select_break = select_break;
exports.property_break = property_break;
exports.is_in_stmt = is_in_stmt;
exports.is_in_stmt_list = is_in_stmt_list;
exports.void_label = void_label;
exports.void_label_tree = void_label_tree;
exports.void_label_tree_list = void_label_tree_list;
exports.set_at_tree = set_at_tree;
exports.set_at_tree_list = set_at_tree_list;
exports.set_labelling_tree = set_labelling_tree;
exports.set_labelling_tree_list = set_labelling_tree_list;
exports.built_abstract_syntax = built_abstract_syntax;
/* No side effect */
